/*
 * stack.c - Реализация функций для работы со стеком и математических функций
 * 
 * Автор: jerrycar
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "stack.h"

// ============================================================================
// РАБОТА СО СТЕКОМ
// ============================================================================

// jerrycar: Создание стека
Stack* create_stack(int capacity) {
    /*
     * ПСЕВДОКОД:
     * 1. Выделить память для структуры Stack
     * 2. Выделить память для массива данных
     * 3. Инициализировать top = -1
     * 4. Установить capacity
     * 5. Вернуть указатель на стек
     */
    return NULL;
}

// jerrycar: Добавление элемента в стек
void push(Stack* stack, Token token) {
    /*
     * ПСЕВДОКОД:
     * 1. Проверить, не переполнен ли стек
     * 2. Увеличить top
     * 3. Поместить token в data[top]
     */
}

// jerrycar: Извлечение элемента из стека
Token pop(Stack* stack) {
    /*
     * ПСЕВДОКОД:
     * 1. Проверить, не пуст ли стек
     * 2. Взять элемент из data[top]
     * 3. Уменьшить top
     * 4. Вернуть элемент
     */
    Token token = {0};
    return token;
}

// jerrycar: Просмотр верхнего элемента стека
Token peek(Stack* stack) {
    /*
     * ПСЕВДОКОД:
     * 1. Проверить, не пуст ли стек
     * 2. Вернуть элемент из data[top] без изменения top
     */
    Token token = {0};
    return token;
}

// jerrycar: Проверка, пуст ли стек
int is_empty(Stack* stack) {
    /*
     * ПСЕВДОКОД:
     * 1. Вернуть 1 если top == -1, иначе 0
     */
    return 1;
}

// jerrycar: Освобождение памяти стека
void free_stack(Stack* stack) {
    /*
     * ПСЕВДОКОД:
     * 1. Освободить память массива data
     * 2. Освободить память структуры stack
     */
}

// ============================================================================
// РАБОТА СО СПИСКОМ ЛЕКСЕМ
// ============================================================================

// jerrycar: Создание списка лексем
TokenList* create_token_list(int capacity) {
    /*
     * ПСЕВДОКОД:
     * 1. Выделить память для структуры TokenList
     * 2. Выделить память для массива tokens
     * 3. Инициализировать count = 0
     * 4. Установить capacity
     * 5. Вернуть указатель на список
     */
    return NULL;
}

// jerrycar: Добавление токена в список
void add_token(TokenList* list, Token token) {
    /*
     * ПСЕВДОКОД:
     * 1. Проверить, не переполнен ли список
     * 2. Добавить token в tokens[count]
     * 3. Увеличить count
     */
}

// jerrycar: Освобождение памяти списка
void free_token_list(TokenList* list) {
    /*
     * ПСЕВДОКОД:
     * 1. Освободить память массива tokens
     * 2. Освободить память структуры list
     */
}

// ============================================================================
// МАТЕМАТИЧЕСКИЕ ФУНКЦИИ
// ============================================================================

// jerrycar: Применение математической функции
double apply_function(const char* func_name, double x) {
    /*
     * ПСЕВДОКОД:
     * 1. Сравнить func_name с известными функциями
     * 2. Вызвать соответствующую функцию
     * 3. Вернуть результат
     */
    return 0.0;
}

// jerrycar: Синус
double my_sin(double x) {
    /*
     * ПСЕВДОКОД:
     * 1. Вернуть sin(x) из math.h
     */
    return 0.0;
}

// jerrycar: Косинус
double my_cos(double x) {
    /*
     * ПСЕВДОКОД:
     * 1. Вернуть cos(x) из math.h
     */
    return 0.0;
}

// jerrycar: Тангенс
double my_tan(double x) {
    /*
     * ПСЕВДОКОД:
     * 1. Вернуть tan(x) из math.h
     */
    return 0.0;
}

// jerrycar: Котангенс
double my_ctg(double x) {
    /*
     * ПСЕВДОКОД:
     * 1. Вернуть 1.0 / tan(x)
     */
    return 0.0;
}

// jerrycar: Квадратный корень
double my_sqrt(double x) {
    /*
     * ПСЕВДОКОД:
     * 1. Проверить, что x >= 0
     * 2. Вернуть sqrt(x) из math.h
     */
    return 0.0;
}

// jerrycar: Натуральный логарифм
double my_ln(double x) {
    /*
     * ПСЕВДОКОД:
     * 1. Проверить, что x > 0
     * 2. Вернуть log(x) из math.h
     */
    return 0.0;
}

// ============================================================================
// ОБРАБОТКА ОПЕРАТОРОВ
// ============================================================================

// jerrycar: Проверка, является ли символ оператором
int is_operator(char c) {
    /*
     * ПСЕВДОКОД:
     * 1. Проверить, является ли c одним из: +, -, *, /
     * 2. Вернуть 1 если да, 0 если нет
     */
    return 0;
}

// jerrycar: Получение приоритета оператора
int get_precedence(char op) {
    /*
     * ПСЕВДОКОД:
     * 1. Для *, / вернуть 2
     * 2. Для +, - вернуть 1
     * 3. Для остальных вернуть 0
     */
    return 0;
}

// jerrycar: Проверка левой ассоциативности оператора
int is_left_associative(char op) {
    /*
     * ПСЕВДОКОД:
     * 1. Для +, -, *, / вернуть 1 (левая ассоциативность)
     * 2. Для остальных вернуть 0
     */
    return 1;
}

// jerrycar: Применение оператора к двум операндам
double apply_operator(char op, double a, double b) {
    /*
     * ПСЕВДОКОД:
     * 1. В зависимости от op:
     *    - '+' вернуть a + b
     *    - '-' вернуть a - b
     *    - '*' вернуть a * b
     *    - '/' проверить b != 0 и вернуть a / b
     * 2. При ошибке вернуть 0
     */
    return 0.0;
} 